/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class NDKTools */

#ifndef _Included_cn_linkfeeling_hankserve_bean_NDKTools
#define _Included_cn_linkfeeling_hankserve_bean_NDKTools
#ifdef __cplusplus
extern "C" {
#endif
//#include <NDKTool.h>
#include <stdio.h>

#define DEVICE_LEN 50       //传感器中参与距离计算的数据量
#define MOVE 30      //平移要求量
#define AMP 100      //归一要求比例

#define  MAX_WATCH_DATA_LEN 80
#define  MAX_DEVICE_DATA_LEN 130

#define MAX_MAC_ADDR_LEN 4
#define MAX_DEVICE_NAME_LEN 6

typedef struct tag_raw_data
{
	char x;
	char y;
	char z;
}ACCEL_DATA;

typedef struct tag_watch_data
{
	ACCEL_DATA  data[MAX_WATCH_DATA_LEN];
}WATCH_DATA;

//滑窗
void average_data(char* pdata, char len)
{
	char index;
	for (index = 0; index < (len - 2); index++)
	{
		pdata[index] = (pdata[index] + pdata[index + 1] + pdata[index + 2]) / 3;
	}
}

//数据归一化（同步化）函数
void same_amp_data(char* pdata, char len, short minu,char average)
{
	char index;
	for (index = 0; index < len; index++)
	{
		pdata[index] = (pdata[index] - average) * AMP / minu;
	}
}

//过滤一半数据
void filter_data(char* in_data, unsigned char in_data_len, char* out_data, unsigned char*  out_data_len)
{
	unsigned char in_index;
	unsigned char out_index = 0;
	for (in_index = 0; in_index < in_data_len; in_index += 2)
	{
		out_data[out_index] = in_data[in_index];
		out_index++;
	}
	*out_data_len = out_index;
}

//计算数组的最大值与最小值之差
short minu_data(char* in_data, char in_data_len)
{
	char index;
	char max;
	char min;
	short  minu;
	max = in_data[0];
	min = in_data[0];
	for (index = 0; index < in_data_len; index++)
	{
		if (in_data[index] < min)
			min = in_data[index];
		else if (in_data[index] > max)
			max = in_data[index];
	}
	minu = max - min+1;
	return minu;
}

//计算数组的平均值
short average_data_one(char* in_data, unsigned char in_data_len)
{
	short  sum=0;
	unsigned char index;
	short  average;
	for (index = 0; index < in_data_len; index++)
	{
		sum = sum + in_data[index];
	}
	average = sum / in_data_len;
	return average;
}

// 计算平移最小距离函数
int min_sumlen_data(char* in_data_wa, char* in_data_s)
{
	char index_i;
	char index_j;
	int sumlen;
	int sumlen_time;
	int min_sumlen = 200000;
	for (index_i = 0; index_i < MOVE; index_i++)
	{
		sumlen = 0;
		for (index_j = 0; index_j < DEVICE_LEN; index_j++)
		{
			sumlen_time = (in_data_s[index_j] - in_data_wa[index_j + index_i]) * (in_data_s[index_j] - in_data_wa[index_j + index_i]);
			sumlen = sumlen + sumlen_time;
		}
		if (sumlen < min_sumlen)
		{
			min_sumlen = sumlen;
		}
	}
	return min_sumlen;
}


//主要代码部分
 unsigned int  match_data(char* device_data, char* jwatch_data)
{

	short minu_x;
	short minu_y;
	short minu_z;
	short minu_s;

	int min_sumlen_x;
	int min_sumlen_y;
	int min_sumlen_z;
	unsigned int min_number;

	short average_x;
	short average_y;
	short average_z;
	short average_s;
	char index;
	char index_s;
	char x_raw_data[MAX_WATCH_DATA_LEN];
	char y_raw_data[MAX_WATCH_DATA_LEN];
	char z_raw_data[MAX_WATCH_DATA_LEN];

	char device_raw_data[MAX_DEVICE_DATA_LEN] = {0};
	char device_smooth_data[DEVICE_LEN] = {0};
	char device_real_data_len;

	WATCH_DATA *watch_data;


    watch_data  = (WATCH_DATA*)jwatch_data;
	/* trans data to buffer */
	for (index = 0; index < MAX_WATCH_DATA_LEN; index++)
	{
		x_raw_data[index] = watch_data->data[index].x;
		y_raw_data[index] = watch_data->data[index].y;
		z_raw_data[index] = watch_data->data[index].z;
	}

	filter_data(device_data, MAX_DEVICE_DATA_LEN,  &device_raw_data[0],  &device_real_data_len);
	//结构体里的带到函数里要用&符号，单个数据，带出来的数组不用带&符号，因为本身就带指针，带出来的数据需要用&符号带出

	//平滑曲线
	for (index_s = 0; index_s < DEVICE_LEN; index_s++)
	{
		device_smooth_data[index_s] = (device_raw_data[index_s + 13] + device_raw_data[index_s + 14] + device_raw_data[index_s + 15]) / 3;
	}
	average_data(x_raw_data, MAX_WATCH_DATA_LEN);
	average_data(y_raw_data, MAX_WATCH_DATA_LEN);
	average_data(z_raw_data, MAX_WATCH_DATA_LEN);

	//求数组的平均值
	average_x = average_data_one(x_raw_data, MAX_WATCH_DATA_LEN);
	average_y = average_data_one(y_raw_data, MAX_WATCH_DATA_LEN);
	average_z = average_data_one(z_raw_data, MAX_WATCH_DATA_LEN);
	average_s = average_data_one(device_smooth_data, DEVICE_LEN);

	//求数组最大与最小值差
	minu_x = minu_data(x_raw_data, MAX_WATCH_DATA_LEN);
	minu_y = minu_data(y_raw_data, MAX_WATCH_DATA_LEN);
	minu_z = minu_data(z_raw_data, MAX_WATCH_DATA_LEN);
	minu_s = minu_data(device_smooth_data, DEVICE_LEN);

	//同步归一化
	same_amp_data(x_raw_data, MAX_WATCH_DATA_LEN, minu_x, average_x);
	same_amp_data(y_raw_data, MAX_WATCH_DATA_LEN, minu_y, average_y);
	same_amp_data(z_raw_data, MAX_WATCH_DATA_LEN, minu_z, average_z);
	same_amp_data(device_smooth_data, DEVICE_LEN, minu_s, average_s);


	//求距离
	min_sumlen_x = min_sumlen_data(x_raw_data, device_smooth_data);
	min_sumlen_y = min_sumlen_data(y_raw_data, device_smooth_data);
	min_sumlen_z = min_sumlen_data(z_raw_data, device_smooth_data);
	printf("min_sumlen_x:%d\n", min_sumlen_x);
	printf("min_sumlen_y:%d\n", min_sumlen_y);
	printf("min_sumlen_z:%d\n", min_sumlen_z);
	min_number = min_sumlen_x;
	if (min_sumlen_y < min_number)
		min_number = min_sumlen_y;
	if (min_sumlen_z < min_number)
		min_number = min_sumlen_z;

	return min_number;

}
/*
 * Class:     NDKTools
 * Method:    getStringFromNDK
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_cn_linkfeeling_hankserve_bean_NDKTools_getStringFromNDK
  (JNIEnv *env, jclass jobj){
        return (*env)->NewStringUTF(env,"JNI NDK demo");
  }


JNIEXPORT jint JNICALL Java_cn_linkfeeling_hankserve_bean_NDKTools_match_1data
(JNIEnv *env, jclass jobj, jbyteArray deviceData, jobject watchData){
    jint ret;

    jclass clazz = (*env)->FindClass(env,"cn/linkfeeling/hankserve/bean/WatchData");

    jfieldID arrFieldId = (*env)->GetFieldID(env,clazz, "data", "[B");
    if (arrFieldId == 0) return 0;
    jbyteArray jarr = (jbyteArray) (*env)->GetObjectField(env,watchData, arrFieldId);
    jbyte *arr = (*env)->GetByteArrayElements(env,jarr, 0);
    ret =  match_data(deviceData,arr);
    return ret;
}

#ifdef __cplusplus
}
#endif
#endif

