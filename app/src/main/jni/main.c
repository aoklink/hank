/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>

/* Header for class NDKTools */

#ifndef _Included_cn_linkfeeling_hankserve_bean_NDKTools
#define _Included_cn_linkfeeling_hankserve_bean_NDKTools
#ifdef __cplusplus



extern "C" {
#endif
//#include <NDKTool.h>
#include <stdio.h>
#include <android/log.h>

#define TAG "NativeJni"

#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__) // 定义LOGD类型


#define DEVICE_LEN 25       //传感器中参与距离计算的数据量
#define MOVE 15      //平移要求量
#define AMP 100      //归一要求比例

#define  MAX_WATCH_DATA_LEN 40
#define  MAX_DEVICE_DATA_LEN 130

#define MAX_MAC_ADDR_LEN 4
#define MAX_DEVICE_NAME_LEN 6

typedef struct tag_raw_data {
    signed char  x;
	signed char  y;
    signed char  z;
} ACCEL_DATA;

typedef struct tag_watch_data {
	ACCEL_DATA data[MAX_WATCH_DATA_LEN];
} WATCH_DATA;

//滑窗
void average_data(signed char *pdata, unsigned char len) {
	unsigned char index;
	for (index = 0; index < (len - 2); index++) {
		pdata[index] = (pdata[index] + pdata[index + 1] + pdata[index + 2]) / 3;
	}
}

//数据归一化（同步化）函数
void same_amp_data(signed char *pdata, unsigned char len, short minu, signed char average) {
	unsigned char index;
	for (index = 0; index < len; index++) {
		pdata[index] = (pdata[index] - average) * AMP / minu;
	}
}

//过滤一半数据
void filter_data(signed char *in_data, unsigned char in_data_len, signed char *out_data, unsigned char *out_data_len) {
	unsigned char in_index;
	unsigned char out_index = 0;
	for (in_index = 0; in_index < in_data_len; in_index += 4) {
		out_data[out_index] = in_data[in_index];
		out_index++;
	}
	*out_data_len = out_index;
}

//计算数组的最大值与最小值之差
short minu_data(signed char *in_data, unsigned char in_data_len) {
	unsigned char index;
	signed char max;
	signed char min;
	short minu;
	max = in_data[0];
	min = in_data[0];
	for (index = 0; index < in_data_len; index++) {
		if (in_data[index] < min)
			min = in_data[index];
		else if (in_data[index] > max)
			max = in_data[index];
	}
	minu = max - min + 1;
	return minu;
}

//计算数组的平均值
short average_data_one(signed char *in_data, unsigned char in_data_len) {
	short sum = 0;
	unsigned char index;
	short average;
	for (index = 0; index < in_data_len; index++) {
		sum = sum + in_data[index];
	}
	average = sum / in_data_len;
	return average;
}

// 计算平移最小距离函数
int min_sumlen_data(signed char *in_data_wa, signed char *in_data_s) {
	unsigned char index_i;
	unsigned char index_j;
	int sumlen;
	int sumlen_time;
	int min_sumlen = 200000;
	for (index_i = 0; index_i < MOVE; index_i++) {
		sumlen = 0;
		for (index_j = 0; index_j < DEVICE_LEN; index_j++) {
			sumlen_time = (in_data_s[index_j] - in_data_wa[index_j + index_i]) *
						  (in_data_s[index_j] - in_data_wa[index_j + index_i]);
			sumlen = sumlen + sumlen_time;
		}
		if (sumlen < min_sumlen) {
			min_sumlen = sumlen;
		}
	}
	return min_sumlen;
}


//主要代码部分
unsigned int match_data(signed char *device_data, WATCH_DATA *watch_data) {
	short minu_x;
	short minu_y;
	short minu_z;
	short minu_s;

	int min_sumlen_x;
	int min_sumlen_y;
	int min_sumlen_z;
	int min_sumlen_fx;
	int min_sumlen_fy;
	int min_sumlen_fz;
	unsigned int min_number;

	short average_x;
	short average_y;
	short average_z;
	short average_s;
	short average_fs;
	unsigned char index;
	unsigned char index_s;
	signed char x_raw_data[MAX_WATCH_DATA_LEN];
	signed char y_raw_data[MAX_WATCH_DATA_LEN];
	signed char z_raw_data[MAX_WATCH_DATA_LEN];

	signed char device_raw_data[MAX_DEVICE_DATA_LEN] = {0};
	signed char device_smooth_data[DEVICE_LEN] = {0};
	unsigned char device_real_data_len;
	signed char flip_device_data[DEVICE_LEN];

	/* trans data to buffer */
	for (index = 0; index < MAX_WATCH_DATA_LEN; index++) {
		x_raw_data[index] = watch_data->data[index].x;
		y_raw_data[index] = watch_data->data[index].y;
		z_raw_data[index] = watch_data->data[index].z;
        LOGD("xxxxxxxx %d,%d,%d",x_raw_data[index],y_raw_data[index],z_raw_data[index]);
	}

	LOGD("ppppppppp %d,%d,%d,%d",device_data[0],device_data[1],device_data[128],device_data[129]);
	filter_data(device_data, MAX_DEVICE_DATA_LEN, &device_raw_data[0], &device_real_data_len);
	//结构体里的带到函数里要用&符号，单个数据，带出来的数组不用带&符号，因为本身就带指针，带出来的数据需要用&符号带出

	//平滑曲线
	for (index_s = 0; index_s < DEVICE_LEN; index_s++) {
		device_smooth_data[index_s] =
				(device_raw_data[index_s + 5] + device_raw_data[index_s + 6] +
				 device_raw_data[index_s + 7]) / 3;
	}
	for(index_s=0; index_s<DEVICE_LEN; index_s++)
	{
		flip_device_data[index_s] = 0 - device_smooth_data[index_s];
	}
	average_data(x_raw_data, MAX_WATCH_DATA_LEN);
	average_data(y_raw_data, MAX_WATCH_DATA_LEN);
	average_data(z_raw_data, MAX_WATCH_DATA_LEN);

	//求数组的平均值
	average_x = average_data_one(x_raw_data, MAX_WATCH_DATA_LEN);
	average_y = average_data_one(y_raw_data, MAX_WATCH_DATA_LEN);
	average_z = average_data_one(z_raw_data, MAX_WATCH_DATA_LEN);
	average_s = average_data_one(device_smooth_data, DEVICE_LEN);
	average_fs = average_data_one(flip_device_data, DEVICE_LEN);

	LOGD("pingjunzhi %d,%d,%d,%d",average_x,average_y,average_z,average_s);


	//求数组最大与最小值差
	minu_x = minu_data(x_raw_data, MAX_WATCH_DATA_LEN);
	minu_y = minu_data(y_raw_data, MAX_WATCH_DATA_LEN);
	minu_z = minu_data(z_raw_data, MAX_WATCH_DATA_LEN);
	minu_s = minu_data(device_smooth_data, DEVICE_LEN);

	LOGD("pingjunzhizuidazuixiao %d,%d,%d,%d",minu_x,minu_y,minu_z,minu_s);


	//同步归一化
	same_amp_data(x_raw_data, MAX_WATCH_DATA_LEN, minu_x, average_x);
	same_amp_data(y_raw_data, MAX_WATCH_DATA_LEN, minu_y, average_y);
	same_amp_data(z_raw_data, MAX_WATCH_DATA_LEN, minu_z, average_z);
	same_amp_data(device_smooth_data, DEVICE_LEN, minu_s, average_s);
	same_amp_data(flip_device_data, DEVICE_LEN, minu_s, average_fs);


	//求距离
	min_sumlen_x = min_sumlen_data(x_raw_data, device_smooth_data);
	min_sumlen_y = min_sumlen_data(y_raw_data, device_smooth_data);
	min_sumlen_z = min_sumlen_data(z_raw_data, device_smooth_data);
	min_sumlen_fx = min_sumlen_data(x_raw_data, flip_device_data);
	min_sumlen_fy = min_sumlen_data(y_raw_data, flip_device_data);
	min_sumlen_fz = min_sumlen_data(z_raw_data, flip_device_data);

	LOGD("min_sumlen_x:%d\n", min_sumlen_x);
	LOGD("min_sumlen_y:%d\n", min_sumlen_y);
	LOGD("min_sumlen_z:%d\n", min_sumlen_z);
	min_number = min_sumlen_x;
	if (min_sumlen_y < min_number)
		min_number = min_sumlen_y;
	if (min_sumlen_z < min_number)
		min_number = min_sumlen_z;
	if (min_sumlen_fx < min_number)
		min_number = min_sumlen_fx;
	if (min_sumlen_fy < min_number)
		min_number = min_sumlen_fy;
	if (min_sumlen_fz < min_number)
		min_number = min_sumlen_fz;


	return min_number;


}


/*
 * Class:     NDKTools
 * Method:    getStringFromNDK
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_cn_linkfeeling_hankserve_bean_NDKTools_getStringFromNDK
  (JNIEnv *env, jclass jobj){
        return (*env)->NewStringUTF(env,"JNI NDK demo");
  }


JNIEXPORT jint JNICALL Java_cn_linkfeeling_hankserve_bean_NDKTools_match_1data
(JNIEnv *env, jclass jobj, jbyteArray deviceData, jobject watchData){
    jint ret;
    WATCH_DATA watch_data_temp;

    jbyte * pDevice = (*env)->GetByteArrayElements(env,deviceData, 0);


   // jclass clazz = (*env)->FindClass(env,"cn/linkfeeling/hankserve/bean/WatchData");
    jclass clazz= (*env)->GetObjectClass(env,watchData);
    jfieldID arrFieldId = (*env)->GetFieldID(env,clazz, "data", "[Lcn/linkfeeling/hankserve/bean/AccelData;");
    if (arrFieldId == 0) return 0;
    jobjectArray jarr = (jobjectArray) (*env)->GetObjectField(env,watchData, arrFieldId);
   // jobject *arr = (*env)->GetObjectArrayElement(env,jarr, 0);

	int size =(*env)->GetArrayLength(env,jarr);
	LOGD("########## size = %d", size);


    for(int index = 0;index < MAX_WATCH_DATA_LEN;index++)
    {
        jobject bb = (jobject) (*env)->GetObjectArrayElement(env,jarr, index);
        if(bb==NULL){
			LOGD("##########我是null");

			return NULL;
        }
        jclass cls = (*env)->GetObjectClass(env,bb);
        jfieldID x_fID = (*env)->GetFieldID(env,cls,"x","B");
        jfieldID y_fID = (*env)->GetFieldID(env,cls,"y","B");
        jfieldID z_fID = (*env)->GetFieldID(env,cls,"z","B");
        jbyte x_value = (*env)->GetByteField(env,bb, x_fID);
        jbyte y_value = (*env)->GetByteField(env,bb, y_fID);
        jbyte z_value = (*env)->GetByteField(env,bb, z_fID);

        watch_data_temp.data[index].x = x_value;
        watch_data_temp.data[index].y = y_value;
        watch_data_temp.data[index].z = z_value;
        

        LOGD("########## %d,%d,%d",watch_data_temp.data[index].x,watch_data_temp.data[index].y ,watch_data_temp.data[index].z);
    }

    ret =  match_data(pDevice,&watch_data_temp);

    return ret;
}

#ifdef __cplusplus
}
#endif
#endif

